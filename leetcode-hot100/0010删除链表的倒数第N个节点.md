## 题目描述

给定一个链表，删除链表的倒数第 *n* 个节点，并且返回链表的头结点。

**示例**

```
给定一个链表: 1->2->3->4->5, 和 n = 2.

当删除了倒数第二个节点后，链表变为 1->2->3->5.
```

**说明：**

给定的 *n* 保证是有效的。

**进阶：**

你能尝试使用一趟扫描实现吗？

## 方法一：常规双指针

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* removeNthFromEnd(ListNode* head, int n) {
        ListNode* p_delete = head;
        for(ListNode* p = head; p!=nullptr;){
            if(n==-1)
            {
                while(p!=nullptr){
                    p = p->next;
                    p_delete = p_delete->next;
                }
            }
            else
            {
                p = p->next;
                n--;
            }

        }  
        if(n>-1) //如果循环结束(p=nullptr)并且p_delete还是指向head，并且n还没有到-1。说明要删除的就是head.
        {
            ListNode *ans = head->next;
            delete(head);
            return ans;
        } //只有当n==-1时，才需要删除中间值,因为n保证有效，所以n>=1，所以此时，p一定在p_delete后面，并且p_delete一定不为nullptr.
        ListNode *p = p_delete->next;
        p_delete->next = p_delete->next->next;
        delete(p);
        return head;
    }
};
//时间4ms 空间10.9MB
```

**分析**

- 时间复杂度：O(n)，n是链表的长度。只有一次遍历，只是两个指针同时遍历
- 空间复杂度：O(1)

## 官方答案

```c++
class Solution {
public:
    ListNode* removeNthFromEnd(ListNode* head, int n) {
     ListNode* dummyHead = new ListNode(0);
        dummyHead->next = head;

        ListNode* p = dummyHead;
        ListNode* q = dummyHead;
        for( int i = 0 ; i < n + 1 ; i ++ ){
            q = q->next;
        }

        while(q){
            p = p->next;
            q = q->next;
        }

        ListNode* delNode = p->next;
        p->next = delNode->next;
        delete delNode;

        ListNode* retNode = dummyHead->next;
        delete dummyHead;

        return retNode;
        
    }
};
//一样
```

同上