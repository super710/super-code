## 题目描述

给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有满足条件且不重复的三元组。

注意：答案中不可以包含重复的三元组。

**示例**

```
给定数组 nums = [-1, 0, 1, 2, -1, -4]，

满足要求的三元组集合为：
[
  [-1, 0, 1],
  [-1, -1, 2]
]
```

## 方法一：超时（通过297/318）

```c++
class Solution {
public:
 vector<vector<int>> twoSum(vector<int>& nums, int target, vector<vector<int>> &rets) {
	unordered_map<int, int> hash_map;
	size_t size = nums.size();
	//vector<vector<int>> rets;
	for (int i = 0; i<size; ++i)
	{
		auto pos = hash_map.find(target - nums[i]); // 在hash_map中查找
		if (pos != hash_map.end()){
			rets.push_back({{ pos->second, i }});
		}
		hash_map[nums[i]] = i; //关键---如果没找到，将当前元素插入到map，配对数据可能在后面
	}
	return rets;
}

bool is_repeat(vector<vector<int>> &v1, vector<int> &v){
	//while(it!=v1.rbegin()) it++;
	if (v1.empty()) return false;
	sort((*(v1.rbegin())).begin(), (*(v1.rbegin())).end());
	sort(v.begin(), v.end());
	if (find(v1.begin(), v1.end(), v) != v1.end()) return true;
	else return false;
}
vector<vector<int>> threeSum(vector<int>& nums) {
	//sort(nums.begin(), nums.end());
	size_t size = nums.size();
	//set<int> sets;
	vector<vector<int>> rets;
	//sets.clear();
	for (int i = 0; i < size; ++i)
	{
        vector<vector<int>> ret;
		twoSum(nums, 0 - nums[i], ret);
		if (ret.size()>0){
			for (auto items = ret.begin(); items != ret.end(); items++)
			{
				//cout << (*items)[0] << " " << (*items)[1] << endl;
				if ((*items)[0] != i && (*items)[1] != i){
					vector<int> v = { nums[i], nums[(*items)[0]], nums[(*items)[1]] };
					if (!is_repeat(rets, v)) rets.push_back(move(v));
				}
			}
			//sets.clear();
		}
		ret.clear();
	}
	return rets;
}
};
```

## 改进(通过315/318)

```c++
class Solution {
public:
 bool is_repeat(vector<vector<int>> &v1, vector<int> &v){
	if (v1.empty()) return false;
	if (find(v1.begin(), v1.end(), v) != v1.end()) return true;
	else return false;
}
vector<vector<int>> threeSum(vector<int>& nums) {
	//sort(nums.begin(), nums.end());
	size_t size = nums.size();
	set<int> sets;
	vector<vector<int>> rets;
	sets.clear();
	for (int i = 0; i < size; ++i)
	{
		unordered_map<int, int> hash_map;
		int target = 0 - nums[i];
		for (int j = 0; j<size; ++j)
		{ 
            if(i==j) continue;
			auto pos = hash_map.find(target - nums[j]); // 在hash_map中查找
			if (pos != hash_map.end()){
				vector<int> v = { -target, nums[pos->second], nums[j] };
                sort(v.begin(), v.end());
				if (!is_repeat(rets,v))
				rets.push_back(v);
			}
			hash_map[nums[j]] = j; //关键---如果没找到，将当前元素插入到map，配对数据可能在后面
		}
		hash_map.clear();
	}
	return rets;
}
};
```

## 官方解答：排序+双指针

```c++
class Solution {
public:
vector<vector<int>> threeSum(vector<int>& nums) {
	int size = nums.size();
	sort(nums.begin(), nums.end()); //排序
	vector<vector<int>> ans;
	for (int a = 0; a < size; a++){ //a+b+c = 0
		if(a > 0 && nums[a] == nums[a - 1]) continue; //去除重复的a
		int c = size - 1; //每次让c指向末尾
		int target = -nums[a];
		for (int b = a + 1; b < size; b++){ //b从a后面开始枚举
			if (b>a + 1 && nums[b] == nums[b - 1]) continue; //去除重复的b
			while (c>b && nums[b] + nums[c] > target) c--; //c开始移动，查找那个已经固定的c
			if (c == b) break; //如果c，b重合了，说明没找到，直接break
			else if (nums[b] + nums[c] == target){ //find it
				ans.push_back({ nums[a], nums[b], nums[c] });
			}
		}
	}
	return ans;
}
};

//时间112ms 空间20.1MB
```

**分析**：

- 时间复杂度：O(N^2)其中 N 是数组nums 的长度。两重循环(n^2) + sort(nlgn) = n^2

- 空间复杂度：O(logN)。我们忽略存储答案的空间，额外的排序的空间复杂度为 O(logN)。然而我们修改了输入的数组 nums，在实际情况下不一定允许，因此也可以看成使用了一个额外的数组存储了nums 的副本并进行排序，空间复杂度为O(N)。

