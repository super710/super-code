## 题目描述

给定一个字符串 `s`，找到 `s` 中最长的回文子串。你可以假设 `s` 的最大长度为 1000。

**示例**

```
输入: "babad"
输出: "bab"
注意: "aba" 也是一个有效答案。
```

```
输入: "cbbd"
输出: "bb"
```

## 动态规划

```c++
class Solution {
public:
    string longestPalindrome(string s) {
        int size  = s.size();
        string ans;
        vector<vector<int>> dp(size, vector<int>(size)); //定义size行 size列的二维数组
        for(int j = 0; j<size; ++j){ //用i j表示i到j区间[i, j] //j依次遍历，i在[0, j]范围内遍历
            for(int i = 0; i<j+1; ++i){
                if(i == j) dp[i][j] = true; //边界条件，如果i和j重合，直接true
                else if(i == j-1) dp[i][j] = (s[i]==s[j]); //如果相差一位，相等则为true
                else dp[i][j] = (s[i] == s[j] && dp[i+1][j-1]); //否则动态规划
                if(dp[i][j] && j-i+1>ans.size()) ans = s.substr(i, j-i+1); //判断dp为true且当前是回文串的长度大于记录的ans.size()
            }
        }
        return ans;
    }
};
```

