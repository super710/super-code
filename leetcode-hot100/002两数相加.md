## 题目描述

给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。

如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。

您可以假设除了数字 0 之外，这两个数都不会以 0 开头。

**示例**

```c++
输入：(2 -> 4 -> 3) + (5 -> 6 -> 4)
输出：7 -> 0 -> 8
原因：342 + 465 = 807
```

## 题解

### 方法一：我的方法

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    //用于单个链表进位
    ListNode* upNum(ListNode* l1){
		ListNode* p = l1;
		int v = 1;//默认是进位
		for (; p != NULL; p = p->next){//遍历这个链表，对每一位进行加一
			int add = p->val + 1;
			if (add>9){ //如果此位还有进位，继续下一次循环
				add %= 10;
				p->val = add;
			}
			else{ //否则说明进位结束，跳出循环
				v = 0;
				p->val = add;
				break;
			}
		}
		if (v == 1){ //跳出循环之后需要判断如果是到最后一位是否还有进位
			p = l1;
            if(p==NULL) l1 = new ListNode(1); //传进来的l1本身就是NULL，需要进位，直接新建一个ListNode。
            else{
                while ((p->next) != NULL) p = p->next; //l1不是NULL，尾插一个ListNode
                p->next = new ListNode(1);
            }

		}
		return l1;
	}
	ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {
		int v = 0;
		ListNode *p1, *p2, *ret = NULL, *p = NULL;

		for (p1 = l1, p2 = l2; p1 != NULL&&p2 != NULL; p1 = p1->next, p2 = p2->next){
			if (ret == NULL){ //第一次初始化ret和p
				ret = new ListNode(0);
				p = ret;
			}
			else{
				p->next = new ListNode(0);
				p = p->next;
			}
			int add = p1->val + p2->val + v;
			if (add>9){
				add %= 10;
				v = 1;//进位
			}
			else{
				v = 0; // 取消进位
			}
			p->val = add;

		}
		//四种情况，长短不一，有无进位
		if (p1 == NULL && v == 0){//p2长且无进位，直接把p2链接在后面
			p->next = p2;
		}
		else if (p1 == NULL && v == 1){//p2长且有进位，需要依次将p2后面的进位
			p->next = upNum(p2);
		}
		else if (p2 == NULL && v == 0){
			p->next = p1;
		}
		else if (p2 == NULL && v == 1){
			p->next = upNum(p1);
		}
		return ret;
	}
};
//时间40ms， 空间69.9MB
```

分析：常规方法，一位一位的相加，进位。需要考虑到长短不一且有进位，以及长短相同有进位的情况。时间复杂度：*O(max(*m*,*n*))，空间复杂度：*O*(max(*m*,*n*))

### 方法二：官方答案

```c++
class Solution {
public:
    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {
        ListNode *head = nullptr, *tail = nullptr;
        int carry = 0;
        while (l1 || l2) {
            int n1 = l1 ? l1->val: 0;
            int n2 = l2 ? l2->val: 0;
            int sum = n1 + n2 + carry;
            if (!head) {
                head = tail = new ListNode(sum % 10);
            } else {
                tail->next = new ListNode(sum % 10);
                tail = tail->next;
            }
            carry = sum / 10;
            if (l1) {
                l1 = l1->next;
            }
            if (l2) {
                l2 = l2->next;
            }
        }
        if (carry > 0) {
            tail->next = new ListNode(carry);
        }
        return head;
    }
};
//时间56ms, 空间70MB
```

分析：

- 如果两个链表的长度不同，则可以认为长度短的链表的后面有若干个 0 。
- 如果链表遍历结束后，有 carry >0，还需要在答案链表的后面附加一个节点，节点的值为carry。
- 时间复杂度：*O(max(m,n))*， 其中 m,n 为两个链表的长度。我们要遍历两个链表的全部位置，而处理每个位置只需要 *O(1) *的时间。
- 空间复杂度：*O(max(m,n))*， 答案链表的长度最多为较长链表的长度 +1。